MSP430 Microprocessors (1 board):
------------------------------------------
MSP430G2553
------------------------------------------

8-Bit Counter Interrupt (Extra)
one button for resetting
8 GPIO pins for outputting to 8 LEDs

------------------------------------------

The code begins outside the main block by including the header file stdint.h for the uint16_t function, and then defining the BUTTON. Inside the main block, the first line turns off the on-board watchdog timer control. Eight GPIO pins are set as directional pins, and then set as outputs using hexadecimal values. The capture/compare register (TACCR0) is set to a value of 10000-1 (actually counts from 0 to 99999, which is 10000 counts). The timer control register is configured to continuous mode (MC_2), and its value is multiplied by 8 (ID_3) since the capture/compare control register cannot be larger than 65536. Interrupts are enabled for the capture/compare control register. The NOT of the BUTTON is set as a directional pin. The next two lines calibrate the on-board timer to the desired 1MHz frequency (1MHz by default). In the last line in the main block, all interrupt blocks are enabled. Before the interrupt block, the #pragma vector line is equal to TIMER0_A0_VECTOR, which reads any interrupts coming from TIMER0 (TACCTL0). 

Within the interrupt block, an integer i is declared and equal to 0, serving as the global variable for the for-loop. Inside the infinite for-loop, a while-loop is performed only while the BUTTON is pressed. Inside this while-loop, a second while-loop without any internal code is performed only if the timer has overflowed its value, which essentially makes the program do nothing while overflowing has occured. Back to the overlapping while-loop while the button is pressed, the first line sets the timer control register as the NOT of the timer interrupt flag, resetting the overflow. The i variable is increased by 1. The P2OUT outputs are equal to the binary value of the variable i, which turns on the corresponding LEDs that represent the binary value. The P1OUT outputs are equal to the binary value of the P2OUT pins, which turns on the last two LEDs according to the total binary value of P2OUT. An if-statement (still within the while-loop) only runs when the variable i is equal to 255 (or 11111111 in binary), which then resets the counter back to 0 with i=0. 

Another function block called pattern(int value) is initialized. Within the pattern block, the patterntest variable is set as an unsigned 16 bit integer for the binary counting pattern. The integer i variable is declared. The variable patterntest=0 to serve as a global variable. A for-loop is run, initially setting i=7 and decreasing i by 1 for every iteration, until i is no longer greater than or equal to 0. This for-loop serves to bit-shift the LED pattern (for example, going from 111 to 1000). In this for-loop, an if-statement is run only when the integer "value" is higher than 2 to the power of i (the value of i is determined by the last function block called power). In this if-statement, patterntest is equal to BIT0 (0 or 1, currently in BIT0). The value variable is reset by equaling to value-2^i. Back to the for-loop, an else-statement runs whenever value is not equal to or greater than 2^7, and sets patterntest equal to the NOT of BIT0 (inverting the BIT0 value any time the else-statement is run). Back to the for-loop again, a second if-statement runs only when i is not equal to 0, which then shifts a bit 1 to the left for the binary value of patterntest. Outside of the for-loop, a final line for this function block returns the value of patterntest for future declaractions of the function block.

A final function block called power(int n) is initialized. Two variables i and p are declared, and p=1 to serve as a global variable. A for-loop sets i=1 and increments i by 1 for every iteration, running until i is less than or equal to the integer n. In this for-loop, p=p*2 is looped until i is greater than n (i.e. 1*1=2, 2*2=4, 2*3=6, 2*4=8). Outside this for-loop, the final line of the function block returns the outcome of p for future declarations of the function block.

------------------------------------------
